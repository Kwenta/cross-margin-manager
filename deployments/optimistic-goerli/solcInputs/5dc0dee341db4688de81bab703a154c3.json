{
  "language": "Solidity",
  "sources": {
    "contracts/interfaces/IAddressResolver.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.13;\n\n// https://docs.synthetix.io/contracts/source/interfaces/iaddressresolver\ninterface IAddressResolver {\n    function getAddress(bytes32 name) external view returns (address);\n\n    function getSynth(bytes32 key) external view returns (address);\n\n    function requireAndGetAddress(bytes32 name, string calldata reason) external view returns (address);\n}"
    },
    "contracts/MarginBase.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/structs/BitMaps.sol\";\nimport \"./interfaces/IAddressResolver.sol\";\nimport \"./interfaces/IFuturesMarket.sol\";\nimport \"./interfaces/IFuturesMarketManager.sol\";\nimport \"./interfaces/IMarginBaseTypes.sol\";\nimport \"./interfaces/IMarginBase.sol\";\nimport \"./utils/OpsReady.sol\";\nimport \"./utils/MinimalProxyable.sol\";\nimport \"./MarginBaseSettings.sol\";\n\n/// @title Kwenta MarginBase Account\n/// @author JaredBorders (jaredborders@proton.me), JChiaramonte7 (jeremy@bytecode.llc)\n/// @notice Flexible, minimalist, and gas-optimized cross-margin enabled account\n/// for managing perpetual futures positions\ncontract MarginBase is MinimalProxyable, IMarginBase, OpsReady {\n    using BitMaps for BitMaps.BitMap;\n\n    /*///////////////////////////////////////////////////////////////\n                                Constants\n    ///////////////////////////////////////////////////////////////*/\n\n    /// @notice tracking code used when modifying positions\n    bytes32 private constant TRACKING_CODE = \"KWENTA\";\n\n    /// @notice name for futures market manager, needed for fetching market key\n    bytes32 private constant FUTURES_MANAGER = \"FuturesMarketManager\";\n\n    /// @notice max BPS\n    uint256 private constant MAX_BPS = 10000;\n\n    /// @notice constant for sUSD currency key\n    bytes32 private constant SUSD = \"sUSD\";\n\n    /*///////////////////////////////////////////////////////////////\n                                State\n    ///////////////////////////////////////////////////////////////*/\n\n    // @notice synthetix address resolver\n    IAddressResolver private addressResolver;\n\n    /// @notice synthetix futures market manager\n    IFuturesMarketManager private futuresManager;\n\n    /// @notice settings for MarginBase account\n    MarginBaseSettings public marginBaseSettings;\n\n    /// @notice token contract used for account margin\n    IERC20 public marginAsset;\n\n    /// @notice margin locked for future events (ie. limit orders)\n    uint256 public committedMargin;\n\n    /// @notice active markets bitmap\n    BitMaps.BitMap private markets;\n\n    /// @notice market keys that the account has active positions in\n    bytes32[] public activeMarketKeys;\n\n    /// @notice active market keys mapped to index in activeMarketKeys\n    mapping(bytes32 => uint256) public marketKeyIndex;\n\n    /// @notice limit orders\n    mapping(uint256 => Order) public orders;\n\n    /// @notice sequentially id orders\n    uint256 public orderId;\n\n    /*///////////////////////////////////////////////////////////////\n                                Events\n    ///////////////////////////////////////////////////////////////*/\n\n    /// @notice emitted after a successful deposit\n    /// @param user: the address that deposited into account\n    /// @param amount: amount of marginAsset to deposit into marginBase account\n    event Deposit(address indexed user, uint256 amount);\n\n    /// @notice emitted after a successful withdrawal\n    /// @param user: the address that withdrew from account\n    /// @param amount: amount of marginAsset to withdraw from marginBase account\n    event Withdraw(address indexed user, uint256 amount);\n\n    /// @notice emitted when tokens are rescued from this contract\n    /// @param token: address of token recovered\n    /// @param amount: amount of token recovered\n    event Rescued(address token, uint256 amount);\n\n    /// @notice emitted when an advanced order is placed\n    /// @param account: account placing the order\n    /// @param orderId: id of order\n    /// @param marketKey: futures market key\n    /// @param marginDelta: margin change\n    /// @param sizeDelta: size change\n    /// @param targetPrice: targeted fill price\n    event OrderPlaced(\n        address indexed account,\n        uint256 orderId,\n        bytes32 marketKey,\n        int256 marginDelta,\n        int256 sizeDelta,\n        uint256 targetPrice,\n        OrderTypes orderType\n    );\n\n    /// @notice emitted when an advanced order is cancelled\n    event OrderCancelled(address indexed account, uint256 orderId);\n\n    /// @notice emitted when an advanced order is filled\n    /// @param fillPrice: price the order was executed at\n    /// @param keeperFee: fees paid to the executor\n    event OrderFilled(\n        address indexed account,\n        uint256 orderId,\n        uint256 fillPrice,\n        uint256 keeperFee\n    );\n\n    /// @notice emitted after a fee has been transferred to Treasury\n    /// @param account: the address of the account the fee was imposed on\n    /// @param amount: fee amount sent to Treasury\n    event FeeImposed(address indexed account, uint256 amount);\n\n    /*///////////////////////////////////////////////////////////////\n                                Modifiers\n    ///////////////////////////////////////////////////////////////*/\n\n    /// @notice helpful modifier to check non-zero values\n    /// @param value: value to check if zero\n    modifier notZero(uint256 value, bytes32 valueName) {\n        /// @notice value cannot be zero\n        if (value == 0) {\n            revert ValueCannotBeZero(valueName);\n        }\n        _;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                                Errors\n    ///////////////////////////////////////////////////////////////*/\n\n    /// @notice given value cannot be zero\n    /// @param valueName: name of the variable that cannot be zero\n    error ValueCannotBeZero(bytes32 valueName);\n\n    /// @notice limit size of new position specs passed into distribute margin\n    /// @param numberOfNewPositions: number of new position specs\n    error MaxNewPositionsExceeded(uint256 numberOfNewPositions);\n\n    /// @notice exceeds useable margin\n    /// @param available: amount of useable margin asset\n    /// @param required: amount of margin asset required\n    error InsufficientFreeMargin(uint256 available, uint256 required);\n\n    /// @notice cannot execute invalid order\n    error OrderInvalid();\n\n    /// @notice call to transfer ETH on withdrawal fails\n    error EthWithdrawalFailed();\n\n    /// @notice base price from the oracle was invalid\n    /// @dev Rate can be invalid either due to:\n    ///      1. Returned as invalid from ExchangeRates - due to being stale or flagged by oracle\n    ///      2. Out of deviation bounds w.r.t. to previously stored rate\n    ///      3. if there is no valid stored rate, w.r.t. to previous 3 oracle rates\n    ///      4. Price is zero\n    error InvalidPrice();\n\n    /// @notice cannot rescue underlying margin asset token\n    error CannotRescueMarginAsset();\n\n    /// @notice Insufficient margin to pay fee\n    error CannotPayFee();\n\n    /// @notice Must have a minimum eth balance before placing an order\n    /// @param balance: current ETH balance\n    /// @param minimum: min required ETH balance\n    error InsufficientEthBalance(uint256 balance, uint256 minimum);\n\n    /*///////////////////////////////////////////////////////////////\n                        Constructor & Initializer\n    ///////////////////////////////////////////////////////////////*/\n\n    /// @notice constructor never used except for first CREATE\n    // solhint-disable-next-line\n    constructor() MinimalProxyable() {}\n\n    /// @notice initialize contract (only once) and transfer ownership to caller\n    /// @dev ensure resolver and sUSD addresses are set to their proxies and not implementations\n    /// @param _marginAsset: token contract address used for account margin\n    /// @param _addressResolver: contract address for synthetix address resolver\n    /// @param _marginBaseSettings: contract address for MarginBase account settings\n    /// @param _ops: gelato ops address\n    function initialize(\n        address _marginAsset,\n        address _addressResolver,\n        address _marginBaseSettings,\n        address payable _ops\n    ) external initOnce {\n        marginAsset = IERC20(_marginAsset);\n        addressResolver = IAddressResolver(_addressResolver);\n        futuresManager = IFuturesMarketManager(\n            addressResolver.requireAndGetAddress(\n                FUTURES_MANAGER,\n                \"MarginBase: Could not get Futures Market Manager\"\n            )\n        );\n        marginAsset = IERC20(_marginAsset);\n\n        /// @dev MarginBaseSettings must exist prior to MarginBase account creation\n        marginBaseSettings = MarginBaseSettings(_marginBaseSettings);\n\n        /// @dev the Ownable constructor is never called when we create minimal proxies\n        _transferOwnership(msg.sender);\n\n        ops = _ops;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                                Views\n    ///////////////////////////////////////////////////////////////*/\n\n    /// @notice get number of internal market positions account has\n    /// @return number of positions which are internally accounted for\n    function getNumberOfInternalPositions() external view returns (uint256) {\n        return activeMarketKeys.length;\n    }\n\n    /// @notice the current withdrawable or usable balance\n    function freeMargin() public view returns (uint256) {\n        return marginAsset.balanceOf(address(this)) - committedMargin;\n    }\n\n    /// @notice get up-to-date position data from Synthetix\n    /// @param _marketKey: key for synthetix futures market\n    function getPosition(bytes32 _marketKey)\n        public\n        view\n        returns (\n            uint64 id,\n            uint64 fundingIndex,\n            uint128 margin,\n            uint128 lastPrice,\n            int128 size\n        )\n    {\n        // fetch position data from Synthetix\n        (id, fundingIndex, margin, lastPrice, size) = futuresMarket(_marketKey)\n            .positions(address(this));\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        Account Deposit & Withdraw\n    ///////////////////////////////////////////////////////////////*/\n\n    /// @param _amount: amount of marginAsset to deposit into marginBase account\n    function deposit(uint256 _amount)\n        public\n        notZero(_amount, \"_amount\")\n        onlyOwner\n    {\n        // transfer in margin asset from user\n        // (will revert if user does not have amount specified)\n        require(\n            marginAsset.transferFrom(owner(), address(this), _amount),\n            \"MarginBase: deposit failed\"\n        );\n\n        emit Deposit(msg.sender, _amount);\n    }\n\n    /// @param _amount: amount of marginAsset to withdraw from marginBase account\n    function withdraw(uint256 _amount)\n        external\n        notZero(_amount, \"_amount\")\n        onlyOwner\n    {\n        // make sure committed margin isn't withdrawn\n        if (_amount > freeMargin()) {\n            revert InsufficientFreeMargin(freeMargin(), _amount);\n        }\n\n        // transfer out margin asset to user\n        // (will revert if account does not have amount specified)\n        require(\n            marginAsset.transfer(owner(), _amount),\n            \"MarginBase: withdraw failed\"\n        );\n\n        emit Withdraw(msg.sender, _amount);\n    }\n\n    /// @notice allow users to withdraw ETH deposited for keeper fees\n    /// @param _amount: amount to withdraw\n    function withdrawEth(uint256 _amount) external onlyOwner {\n        // solhint-disable-next-line\n        (bool success, ) = payable(owner()).call{value: _amount}(\"\");\n        if (!success) {\n            revert EthWithdrawalFailed();\n        }\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            Margin Distribution\n    ///////////////////////////////////////////////////////////////*/\n\n    /// @notice accept a deposit amount and open new\n    /// futures market position(s) all in a single tx\n    /// @param _amount: amount of marginAsset to deposit into marginBase account\n    /// @param _newPositions: an array of NewPosition's used to modify active market positions\n    function depositAndDistribute(\n        uint256 _amount,\n        NewPosition[] memory _newPositions\n    ) external onlyOwner {\n        deposit(_amount);\n        _distributeMargin(_newPositions);\n    }\n\n    /// @notice distribute margin across all/some positions specified via _newPositions\n    /// @dev _newPositions may contain any number of new or existing positions\n    /// @dev close and withdraw all margin from position if resulting position size is zero post trade\n    /// @param _newPositions: an array of NewPosition's used to modify active market positions\n    function distributeMargin(NewPosition[] memory _newPositions)\n        external\n        onlyOwner\n    {\n        _distributeMargin(_newPositions);\n    }\n\n    function _distributeMargin(NewPosition[] memory _newPositions) internal {\n        /// @notice limit size of new position specs passed into distribute margin\n        uint256 newPositionsLength = _newPositions.length;\n        if (newPositionsLength > type(uint8).max) {\n            revert MaxNewPositionsExceeded(newPositionsLength);\n        }\n\n        /// @notice tracking variable for calculating fee(s)\n        uint256 tradingFee = 0;\n\n        // for each new position in _newPositions, distribute margin accordingly\n        for (uint8 i = 0; i < newPositionsLength; i++) {\n            // define market params to be used to create or modify a position\n            bytes32 marketKey = _newPositions[i].marketKey;\n            int256 sizeDelta = _newPositions[i].sizeDelta;\n            int256 marginDelta = _newPositions[i].marginDelta;\n\n            // define market\n            IFuturesMarket market = futuresMarket(marketKey);\n\n            // fetch position size from Synthetix\n            (, , , , int128 size) = getPosition(marketKey);\n\n            /// @dev check if position exists internally\n            if (markets.get(uint256(marketKey))) {\n                // check if position was liquidated\n                if (size == 0) {\n                    removeMarketKey(marketKey);\n\n                    // this position no longer exists internally\n                    // thus, treat as new position\n                    if (sizeDelta == 0) {\n                        // position does not exist internally thus, sizeDelta must be non-zero\n                        revert ValueCannotBeZero(\"sizeDelta\");\n                    }\n                }\n                // check if position will be closed by newPosition's sizeDelta\n                else if (size + sizeDelta == 0) {\n                    removeMarketKey(marketKey);\n\n                    // close position and withdraw margin\n                    market.closePositionWithTracking(TRACKING_CODE);\n                    market.withdrawAllMargin();\n\n                    // determine trade fee based on size delta\n                    uint256 fee = calculateTradeFee(_abs(sizeDelta), market);\n\n                    /// @notice impose fee\n                    /// @dev send fee to Kwenta's treasury\n                    bool successfulTransfer = marginAsset.transfer(\n                        marginBaseSettings.treasury(),\n                        fee\n                    );\n                    if (!successfulTransfer) {\n                        revert CannotPayFee();\n                    } else {\n                        emit FeeImposed(address(this), tradingFee);\n                    }\n\n                    // continue to next newPosition\n                    continue;\n                }\n            }\n            /// @dev position does not exist internally thus sizeDelta must be non-zero\n            else if (sizeDelta == 0) {\n                revert ValueCannotBeZero(\"sizeDelta\");\n            }\n\n            /// @notice execute trade\n            /// @dev following trades will not result in position being closed\n            /// @dev following trades may either modify or create a position\n            if (marginDelta < 0) {\n                // remove margin from market and potentially adjust position size\n                tradingFee += modifyPositionForMarketAndWithdraw(\n                    marginDelta,\n                    sizeDelta,\n                    market\n                );\n\n                // update internal accounting\n                addMarketKey(marketKey);\n            } else if (marginDelta > 0) {\n                // deposit margin into market and potentially adjust position size\n                tradingFee += depositAndModifyPositionForMarket(\n                    marginDelta,\n                    sizeDelta,\n                    market\n                );\n\n                // update internal accounting\n                addMarketKey(marketKey);\n            } else if (sizeDelta != 0) {\n                /// @notice adjust position size\n                /// @notice no margin deposited nor withdrawn from market\n                tradingFee += modifyPositionForMarket(sizeDelta, market);\n\n                // update internal accounting\n                addMarketKey(marketKey);\n            }\n        }\n\n        /// @notice impose fee\n        /// @dev send fee to Kwenta's treasury\n        if (tradingFee > 0) {\n            bool successfulTransfer = marginAsset.transfer(\n                marginBaseSettings.treasury(),\n                tradingFee\n            );\n            if (!successfulTransfer) {\n                revert CannotPayFee();\n            } else {\n                emit FeeImposed(address(this), tradingFee);\n            }\n        }\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        Execute Trades\n    ///////////////////////////////////////////////////////////////*/\n\n    /// @notice modify market position's size\n    /// @dev _sizeDelta will always be non-zero\n    /// @param _sizeDelta: size and position type (long/short) denominated in market synth\n    /// @param _market: synthetix futures market\n    /// @return fee *in sUSD*\n    function modifyPositionForMarket(int256 _sizeDelta, IFuturesMarket _market)\n        internal\n        returns (uint256 fee)\n    {\n        // modify position in specific market with KWENTA tracking code\n        _market.modifyPositionWithTracking(_sizeDelta, TRACKING_CODE);\n\n        // determine trade fee based on size delta\n        fee = calculateTradeFee(_abs(_sizeDelta), _market);\n\n        /// @notice alter the amount of margin in specific market position\n        /// @dev positive input triggers a deposit; a negative one, a withdrawal\n        _market.transferMargin(int256(fee) * -1);\n    }\n\n    /// @notice deposit margin into specific market and potentially modify position size\n    /// @dev _depositSize will always be greater than zero\n    /// @dev _sizeDelta may be zero (i.e. market position goes unchanged)\n    /// @param _depositSize: size of deposit in sUSD\n    /// @param _sizeDelta: size and position type (long/short) denominated in market synth\n    /// @param _market: synthetix futures market\n    /// @return fee *in sUSD*\n    function depositAndModifyPositionForMarket(\n        int256 _depositSize,\n        int256 _sizeDelta,\n        IFuturesMarket _market\n    ) internal returns (uint256 fee) {\n        /// @dev ensure trade doesn't spend margin which is not available\n        uint256 absDepositSize = _abs(_depositSize);\n        if (absDepositSize > freeMargin()) {\n            revert InsufficientFreeMargin(freeMargin(), absDepositSize);\n        }\n\n        /// @dev if _sizeDelta is 0, then we do not want to modify position size, only margin\n        if (_sizeDelta != 0) {\n            // determine trade fee based on size delta\n            fee = calculateTradeFee(_abs(_sizeDelta), _market);\n\n            /// @notice alter the amount of margin in specific market position\n            /// @dev positive input triggers a deposit; a negative one, a withdrawal\n            /// @dev subtracting fee ensures margin account has enough margin to pay\n            /// the fee (i.e. effectively fee comes from position)\n            _market.transferMargin(_depositSize - int256(fee));\n\n            // modify position in specific market with KWENTA tracking code\n            _market.modifyPositionWithTracking(_sizeDelta, TRACKING_CODE);\n        } else {\n            /// @notice alter the amount of margin in specific market position\n            /// @dev positive input triggers a deposit; a negative one, a withdrawal\n            _market.transferMargin(_depositSize);\n        }\n    }\n\n    /// @notice potentially modify position size and withdraw margin from market\n    /// @dev _withdrawalSize will always be less than zero\n    /// @dev _sizeDelta may be zero (i.e. market position goes unchanged)\n    /// @param _withdrawalSize: size of sUSD to withdraw from market into account\n    /// @param _sizeDelta: size and position type (long//short) denominated in market synth\n    /// @param _market: synthetix futures market\n    /// @return fee *in sUSD*\n    function modifyPositionForMarketAndWithdraw(\n        int256 _withdrawalSize,\n        int256 _sizeDelta,\n        IFuturesMarket _market\n    ) internal returns (uint256 fee) {\n        /// @dev if _sizeDelta is 0, then we do not want to modify position size, only margin\n        if (_sizeDelta != 0) {\n            // modify position in specific market with KWENTA tracking code\n            _market.modifyPositionWithTracking(_sizeDelta, TRACKING_CODE);\n\n            // determine trade fee based on size delta\n            fee = calculateTradeFee(_abs(_sizeDelta), _market);\n\n            /// @notice alter the amount of margin in specific market position\n            /// @dev positive input triggers a deposit; a negative one, a withdrawal\n            /// @dev subtracting fee ensures margin account has enough margin to pay\n            /// the fee (i.e. effectively fee comes from position)\n            _market.transferMargin(_withdrawalSize - int256(fee));\n        } else {\n            /// @notice alter the amount of margin in specific market position\n            /// @dev positive input triggers a deposit; a negative one, a withdrawal\n            _market.transferMargin(_withdrawalSize);\n        }\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        Internal Accounting\n    ///////////////////////////////////////////////////////////////*/\n\n    /// @notice calculate fee based on both size and given market\n    /// @param _sizeDelta: size delta of given trade\n    /// @param _market: synthetix futures market\n    /// @return fee to be imposed based on size delta\n    function calculateTradeFee(uint256 _sizeDelta, IFuturesMarket _market)\n        internal\n        view\n        returns (uint256 fee)\n    {\n        fee = (_sizeDelta * marginBaseSettings.tradeFee()) / MAX_BPS;\n        /// @notice fee is currently measured in the underlying base asset of the market\n        /// @dev fee will be measured in sUSD, thus exchange rate is needed\n        fee = (sUSDRate(_market) * fee) / 1e18;\n    }\n\n    /// @notice add marketKey to activeMarketKeys\n    /// @param _marketKey to add\n    function addMarketKey(bytes32 _marketKey) internal {\n        if (!markets.get(uint256(_marketKey))) {\n            // add to mapping\n            marketKeyIndex[_marketKey] = activeMarketKeys.length;\n\n            // add to end of array\n            activeMarketKeys.push(_marketKey);\n\n            // add to bitmap\n            markets.setTo(uint256(_marketKey), true);\n        }\n    }\n\n    /// @notice remove index from activeMarketKeys\n    /// @param _marketKey to add\n    function removeMarketKey(bytes32 _marketKey) internal {\n        uint256 index = marketKeyIndex[_marketKey];\n        assert(index < activeMarketKeys.length);\n\n        // remove from mapping\n        delete marketKeyIndex[_marketKey];\n\n        // remove from array\n        for (; index < activeMarketKeys.length - 1; ) {\n            unchecked {\n                // shift element in array to the left\n                activeMarketKeys[index] = activeMarketKeys[index + 1];\n                // update index for given market key\n                marketKeyIndex[activeMarketKeys[index]] = index;\n                index++;\n            }\n        }\n        activeMarketKeys.pop();\n\n        // remove from bitmap\n        markets.setTo(uint256(_marketKey), false);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            Limit Orders\n    ///////////////////////////////////////////////////////////////*/\n\n    /// @notice order logic condition checker\n    /// @dev this is where order type logic checks are handled\n    /// @param _orderId: key for an active order\n    /// @return true if order is valid by execution rules\n    /// @return price that the order will be filled at (only valid if prev is true)\n    function validOrder(uint256 _orderId) public view returns (bool, uint256) {\n        Order memory order = orders[_orderId];\n        if (order.orderType == OrderTypes.LIMIT) {\n            return validLimitOrder(order);\n        } else if (order.orderType == OrderTypes.STOP) {\n            return validStopOrder(order);\n        }\n        // unknown order type\n        // @notice execution should never reach here\n        // @dev needed to satisfy types\n        return (false, 0);\n    }\n\n    /// @notice limit order logic condition checker\n    /// @param order: struct for an active order\n    /// @return true if order is valid by execution rules\n    /// @return price that the order will be filled at (only valid if prev is true)\n    function validLimitOrder(Order memory order)\n        internal\n        view\n        returns (bool, uint256)\n    {\n        uint256 price = sUSDRate(futuresMarket(order.marketKey));\n\n        /// @notice intent is targetPrice or better despite direction\n        if (order.sizeDelta > 0) {\n            // Long\n            return (price <= order.targetPrice, price);\n        } else if (order.sizeDelta < 0) {\n            // Short\n            return (price >= order.targetPrice, price);\n        }\n\n        // sizeDelta == 0\n        // @notice execution should never reach here\n        // @dev needed to satisfy types\n        return (false, price);\n    }\n\n    /// @notice stop order logic condition checker\n    /// @param order: struct for an active order\n    /// @return true if order is valid by execution rules\n    /// @return price that the order will be filled at (only valid if prev is true)\n    function validStopOrder(Order memory order)\n        internal\n        view\n        returns (bool, uint256)\n    {\n        uint256 price = sUSDRate(futuresMarket(order.marketKey));\n\n        /// @notice intent is targetPrice or worse despite direction\n        if (order.sizeDelta > 0) {\n            // Long\n            return (price >= order.targetPrice, price);\n        } else if (order.sizeDelta < 0) {\n            // Short\n            return (price <= order.targetPrice, price);\n        }\n\n        // sizeDelta == 0\n        // @notice execution should never reach here\n        // @dev needed to satisfy types\n        return (false, price);\n    }\n\n    /// @notice register a limit order internally and with gelato\n    /// @param _marketKey: synthetix futures market id/key\n    /// @param _marginDelta: amount of margin (in sUSD) to deposit or withdraw\n    /// @param _sizeDelta: denominated in market currency (i.e. ETH, BTC, etc), size of futures position\n    /// @param _targetPrice: expected limit order price\n    /// @param _orderType: expected order type enum where 0 = LIMIT, 1 = STOP, etc..\n    /// @return orderId contract interface\n    function placeOrder(\n        bytes32 _marketKey,\n        int256 _marginDelta,\n        int256 _sizeDelta,\n        uint256 _targetPrice,\n        OrderTypes _orderType\n    )\n        external\n        payable\n        notZero(_abs(_sizeDelta), \"_sizeDelta\")\n        onlyOwner\n        returns (uint256)\n    {\n        if (address(this).balance < 1 ether / 10) {\n            revert InsufficientEthBalance(address(this).balance, 1 ether / 10);\n        }\n        // if more margin is desired on the position we must commit the margin\n        if (_marginDelta > 0) {\n            // ensure margin doesn't exceed max\n            if (_abs(_marginDelta) > freeMargin()) {\n                revert InsufficientFreeMargin(freeMargin(), _abs(_marginDelta));\n            }\n            committedMargin += _abs(_marginDelta);\n        }\n\n        bytes32 taskId = IOps(ops).createTaskNoPrepayment(\n            address(this), // execution function address\n            this.executeOrder.selector, // execution function selector\n            address(this), // checker (resolver) address\n            abi.encodeWithSelector(this.checker.selector, orderId), // checker (resolver) calldata\n            ETH // payment token\n        );\n\n        orders[orderId] = Order({\n            marketKey: _marketKey,\n            marginDelta: _marginDelta,\n            sizeDelta: _sizeDelta,\n            targetPrice: _targetPrice,\n            gelatoTaskId: taskId,\n            orderType: _orderType\n        });\n\n        emit OrderPlaced(\n            address(this),\n            orderId,\n            _marketKey,\n            _marginDelta,\n            _sizeDelta,\n            _targetPrice,\n            _orderType\n        );\n\n        return orderId++;\n    }\n\n    /// @notice cancel a gelato queued order\n    /// @param _orderId: key for an active order\n    function cancelOrder(uint256 _orderId) external onlyOwner {\n        Order memory order = orders[_orderId];\n\n        // if margin was committed, free it\n        if (order.marginDelta > 0) {\n            committedMargin -= _abs(order.marginDelta);\n        }\n        IOps(ops).cancelTask(order.gelatoTaskId);\n\n        // delete order from orders\n        delete orders[_orderId];\n\n        emit OrderCancelled(address(this), _orderId);\n    }\n\n    /// @notice execute a gelato queued order\n    /// @notice only keepers can trigger this function\n    /// @param _orderId: key for an active order\n    function executeOrder(uint256 _orderId) external onlyOps {\n        (bool isValidOrder, uint256 fillPrice) = validOrder(_orderId);\n        if (!isValidOrder) {\n            revert OrderInvalid();\n        }\n        Order memory order = orders[_orderId];\n\n        // if margin was committed, free it\n        if (order.marginDelta > 0) {\n            committedMargin -= _abs(order.marginDelta);\n        }\n\n        // prep new position\n        MarginBase.NewPosition[]\n            memory newPositions = new MarginBase.NewPosition[](1);\n        newPositions[0] = NewPosition({\n            marketKey: order.marketKey,\n            marginDelta: order.marginDelta,\n            sizeDelta: order.sizeDelta\n        });\n\n        // delete order from orders\n        delete orders[_orderId];\n\n        // execute trade\n        _distributeMargin(newPositions);\n\n        // pay fee\n        (uint256 fee, address feeToken) = IOps(ops).getFeeDetails();\n        _transfer(fee, feeToken);\n\n        emit OrderFilled(address(this), _orderId, fillPrice, fee);\n    }\n\n    /// @notice signal to a keeper that an order is valid/invalid for execution\n    /// @param _orderId: key for an active order\n    /// @return canExec boolean that signals to keeper an order can be executed\n    /// @return execPayload calldata for executing an order\n    function checker(uint256 _orderId)\n        external\n        view\n        returns (bool canExec, bytes memory execPayload)\n    {\n        (canExec, ) = validOrder(_orderId);\n        // calldata for execute func\n        execPayload = abi.encodeWithSelector(\n            this.executeOrder.selector,\n            _orderId\n        );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        Internal Getter Utilities\n    ///////////////////////////////////////////////////////////////*/\n\n    /// @notice addressResolver fetches IFuturesMarket address for specific market\n    /// @param _marketKey: key for synthetix futures market\n    /// @return IFuturesMarket contract interface\n    function futuresMarket(bytes32 _marketKey)\n        internal\n        view\n        returns (IFuturesMarket)\n    {\n        return IFuturesMarket(futuresManager.marketForKey(_marketKey));\n    }\n\n    /// @notice get exchange rate of underlying market asset in terms of sUSD\n    /// @param market: synthetix futures market\n    /// @return price in sUSD\n    function sUSDRate(IFuturesMarket market) internal view returns (uint256) {\n        (uint256 price, bool invalid) = market.assetPrice();\n        if (invalid) {\n            revert InvalidPrice();\n        }\n        return price;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            Utility Functions\n    ///////////////////////////////////////////////////////////////*/\n\n    /// @notice Absolute value of the input, returned as an unsigned number.\n    /// @param x: signed number\n    function _abs(int256 x) internal pure returns (uint256) {\n        return uint256(x < 0 ? -x : x);\n    }\n\n    /// @notice added to support recovering trapped erc20 tokens\n    /// @param tokenAddress: address of token to be recovered\n    /// @param tokenAmount: amount of token to be recovered\n    function rescueERC20(address tokenAddress, uint256 tokenAmount)\n        external\n        onlyOwner\n    {\n        if (tokenAddress == address(marginAsset)) {\n            revert CannotRescueMarginAsset();\n        }\n        IERC20(tokenAddress).transfer(owner(), tokenAmount);\n        emit Rescued(tokenAddress, tokenAmount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/BitMaps.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/structs/BitMaps.sol)\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing uint256 to bool mapping in a compact and efficient way, providing the keys are sequential.\n * Largelly inspired by Uniswap's https://github.com/Uniswap/merkle-distributor/blob/master/contracts/MerkleDistributor.sol[merkle-distributor].\n */\nlibrary BitMaps {\n    struct BitMap {\n        mapping(uint256 => uint256) _data;\n    }\n\n    /**\n     * @dev Returns whether the bit at `index` is set.\n     */\n    function get(BitMap storage bitmap, uint256 index) internal view returns (bool) {\n        uint256 bucket = index >> 8;\n        uint256 mask = 1 << (index & 0xff);\n        return bitmap._data[bucket] & mask != 0;\n    }\n\n    /**\n     * @dev Sets the bit at `index` to the boolean `value`.\n     */\n    function setTo(\n        BitMap storage bitmap,\n        uint256 index,\n        bool value\n    ) internal {\n        if (value) {\n            set(bitmap, index);\n        } else {\n            unset(bitmap, index);\n        }\n    }\n\n    /**\n     * @dev Sets the bit at `index`.\n     */\n    function set(BitMap storage bitmap, uint256 index) internal {\n        uint256 bucket = index >> 8;\n        uint256 mask = 1 << (index & 0xff);\n        bitmap._data[bucket] |= mask;\n    }\n\n    /**\n     * @dev Unsets the bit at `index`.\n     */\n    function unset(BitMap storage bitmap, uint256 index) internal {\n        uint256 bucket = index >> 8;\n        uint256 mask = 1 << (index & 0xff);\n        bitmap._data[bucket] &= ~mask;\n    }\n}\n"
    },
    "contracts/interfaces/IFuturesMarket.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.13;\n\nimport \"./IFuturesMarketBaseTypes.sol\";\n\ninterface IFuturesMarket {\n    /* ========== FUNCTION INTERFACE ========== */\n\n    /* ---------- Market Details ---------- */\n\n    function marketKey() external view returns (bytes32 key);\n\n    function baseAsset() external view returns (bytes32 key);\n\n    function marketSize() external view returns (uint128 size);\n\n    function marketSkew() external view returns (int128 skew);\n\n    function fundingLastRecomputed() external view returns (uint32 timestamp);\n\n    function fundingSequence(uint index) external view returns (int128 netFunding);\n\n    function positions(address account)\n        external\n        view\n        returns (\n            uint64 id,\n            uint64 fundingIndex,\n            uint128 margin,\n            uint128 lastPrice,\n            int128 size\n        );\n\n    function assetPrice() external view returns (uint price, bool invalid);\n\n    function marketSizes() external view returns (uint long, uint short);\n\n    function marketDebt() external view returns (uint debt, bool isInvalid);\n\n    function currentFundingRate() external view returns (int fundingRate);\n\n    function unrecordedFunding() external view returns (int funding, bool invalid);\n\n    function fundingSequenceLength() external view returns (uint length);\n\n    /* ---------- Position Details ---------- */\n\n    function notionalValue(address account) external view returns (int value, bool invalid);\n\n    function profitLoss(address account) external view returns (int pnl, bool invalid);\n\n    function accruedFunding(address account) external view returns (int funding, bool invalid);\n\n    function remainingMargin(address account) external view returns (uint marginRemaining, bool invalid);\n\n    function accessibleMargin(address account) external view returns (uint marginAccessible, bool invalid);\n\n    function liquidationPrice(address account) external view returns (uint price, bool invalid);\n\n    function liquidationFee(address account) external view returns (uint);\n\n    function canLiquidate(address account) external view returns (bool);\n\n    function orderFee(int sizeDelta) external view returns (uint fee, bool invalid);\n\n    function postTradeDetails(int sizeDelta, address sender)\n        external\n        view\n        returns (\n            uint margin,\n            int size,\n            uint price,\n            uint liqPrice,\n            uint fee,\n            IFuturesMarketBaseTypes.Status status\n        );\n\n    /* ---------- Market Operations ---------- */\n\n    function recomputeFunding() external returns (uint lastIndex);\n\n    function transferMargin(int marginDelta) external;\n\n    function withdrawAllMargin() external;\n\n    function modifyPosition(int sizeDelta) external;\n\n    function modifyPositionWithTracking(int sizeDelta, bytes32 trackingCode) external;\n\n    function submitNextPriceOrder(int sizeDelta) external;\n\n    function submitNextPriceOrderWithTracking(int sizeDelta, bytes32 trackingCode) external;\n\n    function cancelNextPriceOrder(address account) external;\n\n    function executeNextPriceOrder(address account) external;\n\n    function closePosition() external;\n\n    function closePositionWithTracking(bytes32 trackingCode) external;\n\n    function liquidatePosition(address account) external;\n}\n"
    },
    "contracts/interfaces/IFuturesMarketManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.13;\n\ninterface IFuturesMarketManager {\n    function markets(uint index, uint pageSize) external view returns (address[] memory);\n\n    function numMarkets() external view returns (uint);\n\n    function allMarkets() external view returns (address[] memory);\n\n    function marketForKey(bytes32 marketKey) external view returns (address);\n\n    function marketsForKeys(bytes32[] calldata marketKeys) external view returns (address[] memory);\n\n    function totalDebt() external view returns (uint debt, bool isInvalid);\n}"
    },
    "contracts/interfaces/IMarginBaseTypes.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.13;\n\n/// @title Kwenta MarginBase Types\n/// @author JaredBorders (jaredborders@proton.me), JChiaramonte7 (jeremy@bytecode.llc)\n/// @notice Types used in Margin Base Accounts\ninterface IMarginBaseTypes {\n    /*///////////////////////////////////////////////////////////////\n                                Types\n    ///////////////////////////////////////////////////////////////*/\n\n    // denotes order types for code clarity\n    /// @dev under the hood LIMIT = 0, STOP = 1\n    enum OrderTypes {\n        LIMIT,\n        STOP\n    }\n\n    // marketKey: synthetix futures market id/key\n    // marginDelta: amount of margin (in sUSD) to deposit or withdraw\n    // sizeDelta: denoted in market currency (i.e. ETH, BTC, etc), size of futures position\n    struct NewPosition {\n        bytes32 marketKey;\n        int256 marginDelta; // positive indicates deposit, negative withdraw\n        int256 sizeDelta;\n    }\n\n    // marketKey: synthetix futures market id/key\n    // marginDelta: amount of margin (in sUSD) to deposit or withdraw\n    // sizeDelta: denoted in market currency (i.e. ETH, BTC, etc), size of futures position\n    // targetPrice: limit or stop price to fill at\n    // gelatoTaskId: unqiue taskId from gelato necessary for cancelling orders\n    // orderType: order type to determine order fill logic\n    struct Order {\n        bytes32 marketKey;\n        int256 marginDelta; // positive indicates deposit, negative withdraw\n        int256 sizeDelta;\n        uint256 targetPrice;\n        bytes32 gelatoTaskId;\n        OrderTypes orderType;\n    }\n}\n"
    },
    "contracts/interfaces/IMarginBase.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.13;\n\nimport \"./IMarginBaseTypes.sol\";\n\n/// @title Kwenta MarginBase Interface\n/// @author JaredBorders (jaredborders@proton.me), JChiaramonte7 (jeremy@bytecode.llc)\ninterface IMarginBase is IMarginBaseTypes {\n    /*///////////////////////////////////////////////////////////////\n                                Views\n    ///////////////////////////////////////////////////////////////*/\n\n    function getNumberOfInternalPositions() external view returns (uint256);\n\n    function freeMargin() external view returns (uint256);\n\n    function getPosition(bytes32 _marketKey)\n        external\n        returns (\n            uint64 id,\n            uint64 fundingIndex,\n            uint128 margin,\n            uint128 lastPrice,\n            int128 size\n        );\n\n    /*///////////////////////////////////////////////////////////////\n                                Mutative\n    ///////////////////////////////////////////////////////////////*/\n\n    // Account Deposit & Withdraw\n    function deposit(uint256 _amount) external;\n\n    function withdraw(uint256 _amount) external;\n\n    function withdrawEth(uint256 _amount) external;\n\n    // Margin Distribution\n    function distributeMargin(NewPosition[] memory _newPositions) external;\n\n    function depositAndDistribute(\n        uint256 _amount,\n        NewPosition[] memory _newPositions\n    ) external;\n\n    // Limit Orders\n    function validOrder(uint256 _orderId) external view returns (bool, uint256);\n    function placeOrder(bytes32 _marketKey, int256 _marginDelta, int256 _sizeDelta, uint256 _targetPrice, OrderTypes _orderType) external payable returns (uint256);\n    function cancelOrder(uint256 _orderId) external;\n\n    function checker(uint256 _orderId)\n        external\n        view\n        returns (bool canExec, bytes memory execPayload);\n\n    // Utility\n    function rescueERC20(address tokenAddress, uint256 tokenAmount) external;\n}\n"
    },
    "contracts/utils/OpsReady.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport {\n    SafeERC20,\n    IERC20\n} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ninterface IOps {\n    function gelato() external view returns (address payable);\n    \n    function createTaskNoPrepayment(\n        address _execAddress,\n        bytes4 _execSelector,\n        address _resolverAddress,\n        bytes calldata _resolverData,\n        address _feeToken\n    ) external returns (bytes32 task);\n\n    function cancelTask(bytes32 _taskId) external;\n\n    function getFeeDetails() external view returns (uint256, address);\n}\n\nabstract contract OpsReady {\n    address public ops;\n    address public constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    modifier onlyOps() {\n        require(msg.sender == ops, \"OpsReady: onlyOps\");\n        _;\n    }\n\n    function gelato() public view returns (address payable) {\n        return IOps(ops).gelato();\n    }\n\n    function _transfer(uint256 _amount, address _paymentToken) internal {\n        if (_paymentToken == ETH) {\n            (bool success, ) = gelato().call{value: _amount}(\"\");\n            require(success, \"_transfer: ETH transfer failed\");\n        } else {\n            SafeERC20.safeTransfer(IERC20(_paymentToken), gelato(), _amount);\n        }\n    }\n}"
    },
    "contracts/utils/MinimalProxyable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract MinimalProxyable is Ownable {\n\n    bool masterCopy;\n    bool initialized;\n\n    constructor() {\n        masterCopy = true;\n    }\n\n    function initialize() public initOnce {}\n\n    modifier initOnce {\n        require(!masterCopy, \"Cannot initialize implementation\");\n        require(!initialized, \"Already initialized\");\n        initialized = true;\n        _;\n    }\n\n}"
    },
    "contracts/MarginBaseSettings.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/// @title Kwenta Settings for MarginBase Accounts\n/// @author JaredBorders (jaredborders@proton.me), JChiaramonte7 (jeremy@bytecode.llc)\n/// @notice Contract (owned by the deployer) for controlling the settings of MarginBase account(s)\n/// @dev This contract will require deployment prior to MarginBase account creation\ncontract MarginBaseSettings is Ownable {\n    /*///////////////////////////////////////////////////////////////\n                                Constants\n    ///////////////////////////////////////////////////////////////*/\n\n    /// @notice decimals calculations\n    uint256 private constant MAX_BPS = 10000;\n\n    /*///////////////////////////////////////////////////////////////\n                        Settings\n    ///////////////////////////////////////////////////////////////*/\n\n    // @notice Kwenta's Treasury Address\n    address public treasury;\n\n    /// @notice denoted in Basis points (BPS) (One basis point is equal to 1/100th of 1%)\n    /// @dev fee imposed on all trades \n    /// @dev trades: defined as changes made to IMarginBaseTypes.NewPosition.size\n    uint256 public tradeFee;\n\n    /// @notice denoted in Basis points (BPS) (One basis point is equal to 1/100th of 1%)\n    /// @dev fee imposed on limit orders\n    uint256 public limitOrderFee;\n\n    /// @notice denoted in Basis points (BPS) (One basis point is equal to 1/100th of 1%)\n    /// @dev fee imposed on stop losses\n    uint256 public stopLossFee;\n\n    /*///////////////////////////////////////////////////////////////\n                                Events\n    ///////////////////////////////////////////////////////////////*/\n\n    /// @notice emitted after changing treasury address\n    /// @param treasury: new treasury address\n    event TreasuryAddressChanged(address treasury);\n\n    /// @notice emitted after a successful trade fee change\n    /// @param fee: fee denoted in BPS\n    event TradeFeeChanged(uint256 fee);\n\n    /// @notice emitted after a successful limit order fee change\n    /// @param fee: fee denoted in BPS\n    event LimitOrderFeeChanged(uint256 fee);\n\n    /// @notice emitted after a successful stop loss fee change\n    /// @param fee: fee denoted in BPS\n    event StopLossFeeChanged(uint256 fee);\n\n    /*///////////////////////////////////////////////////////////////\n                                Errors\n    ///////////////////////////////////////////////////////////////*/\n\n    /// @notice zero address cannot be used\n    error ZeroAddress();\n\n    /// @notice invalid fee (fee >= MAX_BPS)\n    /// @param fee: fee denoted in BPS\n    error InvalidFee(uint256 fee);\n\n    /*///////////////////////////////////////////////////////////////\n                            Constructor\n    ///////////////////////////////////////////////////////////////*/\n\n    /// @notice set initial margin base account fees\n    /// @param _treasury: Kwenta's Treasury Address\n    /// @param _tradeFee: fee denoted in BPS\n    /// @param _limitOrderFee: fee denoted in BPS\n    /// @param _stopLossFee: fee denoted in BPS\n    constructor(\n        address _treasury,\n        uint256 _tradeFee,\n        uint256 _limitOrderFee,\n        uint256 _stopLossFee\n    ) {\n        /// @notice ensure valid address for Kwenta Treasury\n        if (_treasury == address(0)) { revert ZeroAddress(); }\n        \n        /// @notice set Kwenta Treasury address \n        treasury = _treasury;\n\n        /// @notice ensure valid fees\n        if (_tradeFee >= MAX_BPS) { revert InvalidFee(_tradeFee); }\n        if (_limitOrderFee >= MAX_BPS) { revert InvalidFee(_limitOrderFee); }\n        if (_stopLossFee >= MAX_BPS) { revert InvalidFee(_stopLossFee); }\n\n        /// @notice set initial fees\n        tradeFee = _tradeFee;\n        limitOrderFee = _limitOrderFee;\n        stopLossFee = _stopLossFee;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                                Setters\n    ///////////////////////////////////////////////////////////////*/\n\n    /// @notice set new treasury address\n    /// @param _treasury: new treasury address\n    function setTreasury(address _treasury) external onlyOwner {\n        /// @notice ensure valid address for Kwenta Treasury\n        if (_treasury == address(0)) { revert ZeroAddress(); }\n\n        /// @notice set Kwenta Treasury address\n        treasury = _treasury;\n\n        emit TreasuryAddressChanged(_treasury);\n    }\n\n    /// @notice set new trade fee\n    /// @param _fee: fee denoted in BPS\n    function setTradeFee(uint256 _fee) external onlyOwner {\n        /// @notice ensure valid fee\n        if (_fee >= MAX_BPS) { revert InvalidFee(_fee); }\n\n        /// @notice set fee\n        tradeFee = _fee;\n\n        emit TradeFeeChanged(_fee);\n    }\n\n    /// @notice set new limit order fee\n    /// @param _fee: fee denoted in BPS\n    function setLimitOrderFee(uint256 _fee) external onlyOwner {\n        /// @notice ensure valid fee\n        if (_fee >= MAX_BPS) { revert InvalidFee(_fee); }\n\n        /// @notice set fee\n        limitOrderFee = _fee;\n\n        emit LimitOrderFeeChanged(_fee);\n    }\n\n    /// @notice set new stop loss fee\n    /// @param _fee: fee denoted in BPS\n    function setStopLossFee(uint256 _fee) external onlyOwner {\n        /// @notice ensure valid fee\n        if (_fee >= MAX_BPS) { revert InvalidFee(_fee); }\n\n        /// @notice set fee\n        stopLossFee = _fee;\n\n        emit StopLossFeeChanged(_fee);\n    }\n}\n"
    },
    "contracts/interfaces/IFuturesMarketBaseTypes.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.13;\n\ninterface IFuturesMarketBaseTypes {\n    /* ========== TYPES ========== */\n\n    enum Status {\n        Ok,\n        InvalidPrice,\n        PriceOutOfBounds,\n        CanLiquidate,\n        CannotLiquidate,\n        MaxMarketSizeExceeded,\n        MaxLeverageExceeded,\n        InsufficientMargin,\n        NotPermitted,\n        NilOrder,\n        NoPositionOpen,\n        PriceTooVolatile\n    }\n\n    // If margin/size are positive, the position is long; if negative then it is short.\n    struct Position {\n        uint64 id;\n        uint64 lastFundingIndex;\n        uint128 margin;\n        uint128 lastPrice;\n        int128 size;\n    }\n\n    // next-price order storage\n    struct NextPriceOrder {\n        int128 sizeDelta; // difference in position to pass to modifyPosition\n        uint128 targetRoundId; // price oracle roundId using which price this order needs to exucted\n        uint128 commitDeposit; // the commitDeposit paid upon submitting that needs to be refunded if order succeeds\n        uint128 keeperDeposit; // the keeperDeposit paid upon submitting that needs to be paid / refunded on tx confirmation\n        bytes32 trackingCode; // tracking code to emit on execution for volume source fee sharing\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/MarginAccountFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.13;\n\nimport \"./utils/MinimalProxyFactory.sol\";\nimport \"./MarginBase.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @title Kwenta MarginBase Factory\n/// @author JaredBorders (jaredborders@proton.me), JChiaramonte7 (jeremy@bytecode.llc)\n/// @notice Factory which enables deploying a MarginBase account for any user \ncontract MarginAccountFactory is MinimalProxyFactory {\n    \n    string public version; // format: (0.1.0)\n\n    /*///////////////////////////////////////////////////////////////\n                                Immutables\n    ///////////////////////////////////////////////////////////////*/\n\n    /// @notice MarginBase contract acting as user's account\n    MarginBase public immutable implementation;\n\n    /// @notice ERC20 token used to interact with markets\n    IERC20 public immutable marginAsset;\n\n    /// @notice synthetix address resolver\n    address public immutable addressResolver;\n\n    /// @notice settings for MarginBase accounts\n    address public marginBaseSettings;\n    \n    /// @notice gelato ops\n    address payable public immutable ops;\n\n    /*///////////////////////////////////////////////////////////////\n                                Events\n    ///////////////////////////////////////////////////////////////*/\n\n    event NewAccount(address indexed owner, address account);\n\n    /*///////////////////////////////////////////////////////////////\n                                Constructor\n    ///////////////////////////////////////////////////////////////*/\n\n    /// @notice deploy MarginBase implementation to later be cloned\n    /// @param _version: version of contract\n    /// @param _marginAsset: token contract address used for account margin\n    /// @param _addressResolver: contract address for synthetix address resolver\n    /// @param _marginBaseSettings: contract address for MarginBase account settings\n    /// @param _ops: contract address for gelato ops -- must be payable\n    constructor(\n        string memory _version,\n        address _marginAsset,\n        address _addressResolver,\n        address _marginBaseSettings,\n        address payable _ops\n    ) {\n        version = _version;\n        implementation = new MarginBase();\n        marginAsset = IERC20(_marginAsset);\n        addressResolver = _addressResolver;\n\n        /// @dev MarginBaseSettings must exist prior to MarginAccountFactory\n        marginBaseSettings = _marginBaseSettings;\n\n        ops = _ops;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            Account Deployment\n    ///////////////////////////////////////////////////////////////*/\n\n    /// @notice clone MarginBase (i.e. create new account for user)\n    /// @dev this contract is the initial owner of cloned MarginBase,\n    /// but ownership is transferred after successful initialization\n    function newAccount() external returns (address) {\n        MarginBase account = MarginBase(\n            _cloneAsMinimalProxy(address(implementation), \"Creation failure\")\n        );\n        account.initialize(address(marginAsset), addressResolver, marginBaseSettings, ops);\n        account.transferOwnership(msg.sender);\n\n        emit NewAccount(msg.sender, address(account));\n        return address(account);\n    }\n}\n"
    },
    "contracts/utils/MinimalProxyFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\ncontract MinimalProxyFactory {\n    function _cloneAsMinimalProxy(address _base, string memory _revertMsg)\n        internal\n        returns (address clone)\n    {\n        bytes memory createData = _generateMinimalProxyCreateData(_base);\n\n        assembly {\n            clone := create(\n                0, // no value\n                add(createData, 0x20), // data\n                55 // data is always 55 bytes (10 constructor + 45 code)\n            )\n        }\n\n        // If CREATE fails for some reason, address(0) is returned\n        require(clone != address(0), _revertMsg);\n    }\n\n    function _generateMinimalProxyCreateData(address _base)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return\n            abi.encodePacked(\n                //---- constructor -----\n                bytes10(0x3d602d80600a3d3981f3),\n                //---- proxy code -----\n                bytes10(0x363d3d373d3d3d363d73),\n                _base,\n                bytes15(0x5af43d82803e903d91602b57fd5bf3)\n            );\n    }\n}"
    },
    "contracts/interfaces/ISynth.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.13;\n\n// https://docs.synthetix.io/contracts/source/interfaces/isynth\ninterface ISynth {\n    // Views\n    function currencyKey() external view returns (bytes32);\n\n    function transferableSynths(address account) external view returns (uint);\n\n    // Mutative functions\n    function transferAndSettle(address to, uint value) external returns (bool);\n\n    function transferFromAndSettle(\n        address from,\n        address to,\n        uint value\n    ) external returns (bool);\n\n    // Restricted: used internally to Synthetix\n    function burn(address account, uint amount) external;\n\n    function issue(address account, uint amount) external;\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}